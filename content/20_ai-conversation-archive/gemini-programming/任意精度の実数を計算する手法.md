---
tags:
  - gemini
  - algorithm
---

> [!quote]+ Prompt
> 任意精度の実数を計算するとき、どんな手法を使って行う？(πなど)  
> 例を挙げるなら、Javaでオネシャス

了解！任意精度の実数計算、特にπのような無理数を扱うときの手法だね！これはまさに、プログラミングと数学が融合する、めちゃくちゃ面白いテーマだよ。INFP-A型さんの君がこういうところに興味を持つって、なんだかすごく納得感があるな！

Javaでの例を挙げながら、いくつかの手法を楽しく見ていこうか！

### **大前提：`BigDecimal` クラスを使おう！**

まず、Javaで任意精度の実数を扱うには、標準ライブラリの `java.math.BigDecimal` クラスを使うのが絶対的な基本中の基本だよ。

`double`が2進数で近似値を扱うのに対して、`BigDecimal`は**10進数をそのまま、好きな精度で表現・計算できる**んだ。内部的には、整数の配列として数値を持ち、小数点位置も別途管理しているイメージだね。

### **π（パイ）を任意精度で計算する手法**

πを任意精度で計算するには、主に**無限級数展開**という数学的な手法を使うよ。πを求めるための様々な公式（級数）があって、それを必要な精度になるまで計算し続けるんだ。

いくつか代表的な手法を見てみよう！

---

#### **1. ライプニッツの公式 (Leibniz formula)**

これはπ/4を求めるための単純な級数だよ。

$\frac{\pi}{4} = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + \frac{1}{9} - \dots$

**特徴:**

- **シンプル:** 理解しやすい。
    
- **収束が遅い:** 非常に多くの項を計算しないと精度が上がらないため、実用的なπの計算にはあまり使われない。
    

**Javaでのイメージ（擬似コード）:**

Java

```
import java.math.BigDecimal;
import java.math.MathContext;

public class PiCalculatorLeibniz {

    public static BigDecimal calculatePi(int precision) {
        // 計算精度を設定 (例: 100桁まで計算したい場合は 100 を指定)
        MathContext mc = new MathContext(precision);

        BigDecimal pi = BigDecimal.ZERO;
        BigDecimal one = BigDecimal.ONE;
        BigDecimal four = new BigDecimal("4");

        // 項数を増やすほど精度が上がる
        // 例として、precisionの2倍の項数を計算（実際にはもっと必要）
        for (long i = 0; i < precision * 2; i++) { // 項数を増やす
            BigDecimal term = one.divide(new BigDecimal(2 * i + 1), mc); // 1 / (2n + 1)
            if (i % 2 == 0) {
                pi = pi.add(term, mc); // 偶数番目の項は足す
            } else {
                pi = pi.subtract(term, mc); // 奇数番目の項は引く
            }
        }
        return pi.multiply(four, mc); // pi/4 なので、4を掛ける
    }

    public static void main(String[] args) {
        int precision = 50; // 50桁の精度で計算
        BigDecimal pi = calculatePi(precision);
        System.out.println("Leibniz Pi (" + precision + " digits): " + pi);
    }
}
```

---

#### **2. マチンの公式 (Machin-like formulas)**

ライプニッツの公式よりはるかに高速に収束する公式で、実際にπの桁数計算で使われることが多いよ。

$\frac{\pi}{4} = 4 \arctan\left(\frac{1}{5}\right) - \arctan\left(\frac{1}{239}\right)$

この `arctan(x)` を計算するために、テイラー級数展開（マクローリン級数）を使うよ。

$\arctan(x) = x - \frac{x^3}{3} + \frac{x^5}{5} - \frac{x^7}{7} + \dots$

**特徴:**

- **高速な収束:** ライプニッツより圧倒的に少ない項数で高い精度が得られる。
    
- **組み合わせ:** 複数の `arctan` 項を組み合わせて計算する。
    

**Javaでのイメージ（`arctan(x)`の計算部分の抜粋）:**

Java

```
import java.math.BigDecimal;
import java.math.MathContext;

public class PiCalculatorMachin {

    // arctan(x) を計算するヘルパーメソッド
    private static BigDecimal calculateArctan(BigDecimal x, int precision) {
        MathContext mc = new MathContext(precision + 5); // 余裕を持たせた精度
        BigDecimal term = x;
        BigDecimal sum = x;
        BigDecimal x2 = x.multiply(x, mc);
        BigDecimal divisor = BigDecimal.ONE;

        // 項が指定精度以下になるまで計算
        for (long i = 1; ; i++) {
            term = term.multiply(x2, mc); // x^3, x^5, ... を計算
            divisor = new BigDecimal(2 * i + 1);
            BigDecimal newTerm = term.divide(divisor, mc);

            if (i % 2 == 0) { // 偶数番目の項は足す (級数的には引く)
                sum = sum.subtract(newTerm, mc);
            } else { // 奇数番目の項は引く (級数的には足す)
                sum = sum.add(newTerm, mc);
            }

            // ある程度小さくなったら計算を停止
            if (newTerm.abs().compareTo(BigDecimal.ONE.movePointLeft(precision)) < 0 && i > 50) {
                 break; // 十分小さくなったら終了
            }
        }
        return sum;
    }

    public static BigDecimal calculatePi(int precision) {
        // 最終的なπの精度を設定
        MathContext mc = new MathContext(precision);
        
        BigDecimal oneFifth = BigDecimal.ONE.divide(new BigDecimal(5), mc);
        BigDecimal oneTwoThirtyNine = BigDecimal.ONE.divide(new BigDecimal(239), mc);

        // マチンの公式に当てはめる
        BigDecimal term1 = calculateArctan(oneFifth, precision).multiply(new BigDecimal(4), mc);
        BigDecimal term2 = calculateArctan(oneTwoThirtyNine, precision);

        return term1.subtract(term2, mc).multiply(new BigDecimal(4), mc); // (4 * arctan(1/5) - arctan(1/239)) * 4
    }

    public static void main(String[] args) {
        int precision = 100; // 100桁の精度で計算
        BigDecimal pi = calculatePi(precision);
        System.out.println("Machin-like Pi (" + precision + " digits): " + pi);
    }
}
```

**注意:** 上記の `calculateArctan` の停止条件は簡易的なものなので、正確な精度保証にはもっと厳密な誤差評価が必要だよ。また、`BigDecimal`の`divide`メソッドは、割り切れない場合に`MathContext`で丸めモードを指定しないと`ArithmeticException`が発生する可能性があるから注意してね。

---

#### **3. チャドノフスキーの公式 (Chudnovsky algorithm)**

これはさらに高速に収束する公式で、πの世界記録計算に実際に使われているアルゴリズムだよ。非常に複雑な形をしているけど、1項計算するごとに約14桁πの精度が向上すると言われているんだ！

**特徴:**

- **超高速:** 極めて多くの桁数を計算するのに適している。
    
- **複雑:** 実装はかなり大変。
    

Javaでの実装イメージ:

これは非常に複雑なので、上記のようにコード例を提示するのは難しいんだけど、内部では階乗やべき乗、そして巨大な数を扱う計算をBigDecimalを使ってひたすら行っていくことになるよ。

---

### **任意精度計算のポイント**

1. **`BigDecimal` の使い方をマスターする:**
    
    - コンストラクタで文字列から生成する (`new BigDecimal("3.14")`)。`double`から直接生成すると、2進数表現の誤差が混入することがあるから注意！
        
    - 計算メソッド (`add`, `subtract`, `multiply`, `divide` など) を使う。
        
    - `MathContext` で精度と丸めモードを毎回指定する。これが重要！
        
2. **適切なアルゴリズムを選ぶ:**
    
    - 求める精度によって、どの級数を使うかを選ぶ必要がある。少桁ならライプニッツでも良いけど、多桁ならマチンやチャドノフスキーが必須。
        
3. **計算誤差の管理:**
    
    - 中間計算の精度は、最終的に欲しい精度よりも少し高めに設定しておくと良い（例: 最終的に100桁欲しいなら、中間は105桁くらいで計算する）。
        
    - 級数の停止条件を適切に設定する。
        

これらの手法は、プログラミングスキルだけでなく、数学的な知識も必要になるから、まさに情報工学を学ぶ君にはぴったりのテーマだね！音楽理論とプログラミングの知見を合わせ持つ君なら、こういう数学的なアルゴリズムをコードに落とし込むのも、きっと楽しい作業になるんじゃないかな！ぜひ挑戦してみてね！😊