---
tags:
  - gemini
  - rust
  - object-oriented-programming
---

> [!quote]+ Prompt
> Rustにおける、アクセス権限とカプセル化について

お、Rustの**アクセス権限（Visibility）**と**カプセル化（Encapsulation）**に関する質問だね！これはオブジェクト指向的な側面と、Rust独自の安全性設計が交差する、非常に重要なトピックだよ！😎

Rustは「クラス」という概念を持たないけれど、**モジュールシステム**と**`pub`キーワード**を使って、他の言語のカプセル化を遥かに超える、柔軟で強力なアクセス制御を実現しているんだ。

---

## 1. 🔑 アクセス権限の基本ルール：デフォルトはプライベート

Rustにおけるアクセス権限の基本は、非常にシンプルで、かつ厳しいよ。

|**項目**|**デフォルト**|**pub キーワード**|
|---|---|---|
|**アイテム**|**プライベート (`private`)**|**パブリック (`public`)**|
|**定義**|`mod`, `fn`, `struct`, `enum`, `const`, `trait` などすべて。|`pub` を付けることで、外からアクセス可能になる。|
|**原則**|**「外部からのアクセスを許可しない限り、常にプライベート」**|外部に公開したいアイテムにのみ、明示的に `pub` を付ける必要がある。|

これは、**「使われないものは見せない」**というRustのモジュールの原則に基づくもので、デフォルトで最大のカプセル化が実現されていると言えるね！

---

## 2. 🛡️ カプセル化の核：モジュール境界 (`mod`)

Rustのカプセル化は、**モジュール（`mod`）**を単位として行われるんだ。他の言語の「クラス」や「パッケージ」の境界に近い働きをするよ。

### A. 構造体 (`struct`) のカプセル化

構造体自体を `pub` にしても、**その中のフィールド**は**デフォルトでプライベート**のままなんだ。これが、外部から構造体の内部状態を勝手に変更できないようにする、Rust流のカプセル化の核心だよ。

Rust

```
pub struct Configuration {
    pub max_size: u32, // パブリックフィールド（外部から直接アクセス可能）
    secret_key: String, // プライベートフィールド（外部からはアクセス不可）
}
```

この `secret_key` の値を外部から変更したり、読み出したりするには、**メソッド（setter/getter）**を経由する必要がある。これにより、**不変条件（Invariant）**を守りながら、安全に内部状態を操作できるんだ。

### B. Enum のカプセル化

`enum` 自体を `pub` にすると、**そのすべてのバリアント（Variant）**も自動的にパブリックになるよ。これは、`enum` が「すべてのバリアントを知っていて初めて使える」型だからだね。

---

## 3. 🎯 柔軟なアクセス制御 (`pub(crate)`, `pub(super)`, `pub(in path)`)

Rustのアクセス権限が本当に強力なのは、単純な `pub` だけでなく、**公開範囲を限定できる**柔軟なキーワードがある点だよ。

|**キーワード**|**アクセスできる範囲**|**意味合い**|
|---|---|---|
|**`pub`**|**どこからでも**|パッケージ全体、外部クレートからもアクセス可能（完全公開）。|
|**`pub(crate)`**|**現在のクレート内**|現在開発しているライブラリ（クレート）の中だけで公開。外部のユーザーからは見えない。|
|**`pub(super)`**|**親モジュール内**|現在のモジュールを囲んでいる親モジュールとその兄弟モジュールからアクセス可能。|
|**`pub(in path)`**|**指定したパス内**|完全にパスを指定して、特定のモジュール内でのみ公開する。|

### 💡 `pub(crate)` の有用性（豆知識！）

`pub(crate)` は、**内部実装の詳細**を外部に漏らさずに、**クレート全体の協調**を可能にするために非常に便利なんだ。

例えば、クレート内部の複数のモジュールが使う共通のヘルパー関数やデータ構造があるけど、それは外部ユーザーには見せたくない、という場合に最適だよ。これにより、**内部の自由な設計変更**が、外部ユーザーに影響を与えないようにできるんだ。

Rustは、この厳格なアクセス権限とモジュールシステムによって、大規模なプロジェクトでも**意図しないデータの破壊**や**依存関係の複雑化**を防ぎ、堅牢なカプセル化を実現しているんだよ！

他に、特定のケースでのカプセル化の具体的な例について知りたいことはあるかい？例えば、トレイトを使ったカプセル化とか？


> [!quote]+ Prompt
> フィールド変数を、ただpubを付けて終わりにした場合、好き放題出来るのは従来のオブジェクト指向と変わらないかな？  
> 特に、所有権システムにより、より慎重に扱う必要が求められるようになるかな？

その通り！君の認識は**完全に正しい**よ！素晴らしい着眼点だ！🎯✨

Rustで**構造体のフィールドに単に `pub` を付けてしまう**と、従来のオブジェクト指向言語（例えば、パブリックフィールドを持つC#やJavaのクラス）と同じく、そのフィールドは**外部から好き放題に読み書き**できてしまうんだ。

そして、Rustの**所有権システム**と**借用チェッカー**の存在が、この「好き放題」のアクセスを**より厳しく、そしてより複雑な形で**制限することになるよ。

---

## 💥 `pub` フィールドの危険性：従来のオブジェクト指向との比較

### 1. カプセル化の破壊（不変条件の崩壊）

- **従来のオブジェクト指向:** パブリックフィールドを公開すると、そのオブジェクトが持つべき「不変条件」（Invariant。例: 座標の `x` と `y` は常にゼロ以上でなければならない）を、外部コードが簡単に破ってしまう。
    
- **Rustの `pub` フィールド:** 全く同じ問題が発生する。`pub` フィールドを経由すると、`setter` メソッドで本来行うべき**バリデーション（検証）や関連する内部状態の更新**がスキップされてしまい、オブジェクトが**不正な状態**に陥る可能性があるんだ。
    

### 2. Rust独自の「好き放題」の制限

従来の言語と違い、Rustの `pub` フィールドは、以下の**所有権ルール**によって、アクセスがさらに制限されるよ。

#### A. フィールド単位のムーブと所有権

構造体自体が所有権を持つ場合、`pub` フィールドであっても、その中の値を取り出すと**ムーブ（所有権の移動）**が発生するんだ。

Rust

```
pub struct Container {
    pub data: String, // pub だが所有権を持つ
}

let c = Container { data: String::from("hello") };

// ムーブの発生: c.data の所有権が d に移る
let d = c.data; 

// ここで c.data はムーブされて無効になっているため、
// c.data を使った c の操作（例えばメソッド呼び出し）はできなくなる。
// println!("{}", c.data); // -> コンパイルエラー！
```

構造体の一部（フィールド）だけをムーブさせると、構造体全体が**部分的に無効**になる。この挙動は、従来の言語では参照が残るため発生しない、Rust特有の「好き放題」な破壊行為と言えるね！

#### B. 可変性の制限（借用チェッカー）

構造体の一部を変更する（書き込む）には、その構造体全体が**可変であるか、可変な借用を得る**必要がある。

Rust

```
let mut c = Container { data: String::from("A") }; // c は可変

c.data = String::from("B"); // OK、c.data は pub なので直接書き込める

let c2 = Container { data: String::from("C") }; // c2 は不変
// c2.data = String::from("D"); // -> コンパイルエラー！c2が不変だから。
```

`pub` であっても、**その構造体全体が `mut` でない限り、フィールドの書き換えはできない**という制限は、従来の言語よりも厳格だね。

---

## 💡 結論：所有権システムが要求する「より慎重な扱い」

君の言う通り、Rustの `pub` フィールドは、**従来のオブジェクト指向よりもさらに慎重に扱う必要**がある。

|**危険性**|**従来の言語**|**Rustの pub フィールド**|
|---|---|---|
|**カプセル化**|内部状態を壊す。|内部状態を壊す。|
|**所有権の破壊**|発生しない。|**フィールドをムーブすることで、構造体全体を部分的に無効化する。**|
|**不変性の制御**|変数に `const` をつける。|**`let mut` が必須**で、不変性ルールが厳格。|

だからこそ、Rustでは**`pub` フィールドの使用は最小限に留める**のがイディオムであり、値の読み書きが必要な場合でも、**getter/setter メソッド**を経由することが強く推奨されるんだ。