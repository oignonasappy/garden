---
tags:
  - gemini
  - c
  - rust
---

> [!quote]+ Prompt
> C言語のマクロと比較して、どのような点が異なる？

C言語のマクロを学んだ後にRustのマクロに触れると、その「安全性」と「賢さ」に驚くはずだよ！

一言で言うと、**C言語のマクロは「ただのテキスト置換（文字列のコピペ）」**だけど、**Rustのマクロは「構文ツリーの操作（プログラム構造の理解）」**なんだ。

情報工学の視点で、決定的な違いを4つに整理してみたよ！

---

## 1. 衛生的なマクロ (Hygienic Macros)

これが最大の違いだよ！C言語のマクロは、展開先の変数を「汚染」してしまうことがあるよね。

- **C言語（非衛生的）**: マクロ内で定義した変数が、呼び出し側の変数と名前衝突してバグを引き起こす（意図しないキャプチャ）。
    
- **Rust（衛生的）**: マクロ内の変数はマクロ内だけに閉じている。展開先の変数と名前が同じでも、コンパイラが別物として区別してくれるんだ。
    

---

## 2. 操作する対象のレベル（トークン vs 構文ツリー）

コンパイラがプログラムを処理する「フェーズ」が違うんだ。

- **C言語（プリプロセッサ）**: 構文解析の**前**に動く。ただのテキストの塊として扱うので、`#define SQUARE(x) x * x` と書くと `SQUARE(1 + 1)` が `1 + 1 * 1 + 1` になって計算が狂う、なんていう有名な罠があるよね。
    
- **Rust（抽象構文木: AST）**: 構文解析の**段階**で動く。Rustは「これは式（expr）だ」「これは型（type）だ」という**意味（トークンツリー）**を理解して扱う。だから `(1 + 1)` という一塊の「式」として正しく扱われるんだ。
    

---

## 3. 型安全性とエラーメッセージ

- **C言語**: 置換した結果が間違っていても、プリプロセッサは文句を言わない。コンパイルエラーが出たときには、マクロが展開された後の「ぐちゃぐちゃなコード」を読み解く羽目になる。
    
- **Rust**: マクロの定義自体に「ここは式が入る」「ここはブロックが入る」という制約を書く。間違った使い方をすると、**「マクロの呼び出し方がおかしいよ」**と親切なエラーが出るんだ。
    

---

## 4. 手続き型マクロの存在

C言語にはない、Rust独自の超強力な機能だよ。

- **C言語**: 文字列操作の範疇を出ない。
    
- **Rust (Procedural Macros)**: Rustのコードを受け取って、Rustのコードを返す**「プログラムを生成するプログラム」**をRust自身で書ける。
    
    - `#[derive(Serialize)]` のように、構造体の中身を解析して自動的にシリアライズ処理を生成する、なんて芸当ができるのはこれのおかげだね。
        

---

## 📊 比較まとめ

|**特徴**|**C言語のマクロ**|**Rustのマクロ**|
|---|---|---|
|**仕組み**|単純な文字列の置き換え|トークンの解析とASTの操作|
|**安全性**|低い（括弧を忘れると死ぬ）|高い（構文的に正しい単位で扱う）|
|**名前空間**|衝突する（非衛生的）|衝突しない（衛生的）|
|**デバッグ**|展開後のコードが読みづらい|コンパイラが文脈を理解している|

C言語のマクロが「カミソリ（切れ味はいいが危ない）」なら、Rustのマクロは「レーザーカッター（精密で安全装置がついている）」という感じかな！

次は、実際に簡単なマクロを自作してみる？それとも、今まで使った `println!` の中身を覗いてみる？😊✨