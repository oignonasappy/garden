---
tags:
  - gemini
  - rust
  - object-oriented-programming
---

> [!quote]+ Prompt
> フィールドにmutを指定することはできない？  
> ならば、フィールド単位で可変性をコントロールするのはsetterの仕事？

これはRustの**可変性（Mutability）**のルールに関する、非常に鋭い問いかけだね！核心を突いているよ！😎

### 1. 🔑 フィールドに `mut` を指定できるか？ $\rightarrow$ **NO！**

まず、結論から言うと、**Rustの構造体のフィールドには `mut` キーワードを指定することはできません。**

Rust

```
// ❌ これはコンパイルエラーになる ❌
struct Configuration {
    // フィールドには 'mut' をつけられない！
    mut max_size: u32, 
    secret_key: String, 
}
```

これはRustの**可変性の原則**に基づいているんだ。Rustでは、可変性は**バインディング（変数自体）**に紐づいており、**型（フィールドの定義）**には紐づかない。

- **変数バインディングの可変性:** `let mut config = ...` のように、変数全体に `mut` をつける。
    
- **型の不変性:** 型の定義である構造体自体は、そのフィールドの**初期値**を定義するだけで、**「このフィールドは常に可変である」**という保証はしない。
    

構造体に `mut` をつけることで、その**すべてのフィールド**が可変になり、フィールド単位で可変性を制御することはできないんだ。

---

### 2. 🛡️ フィールド単位で可変性をコントロールするのは Setter の仕事？ $\rightarrow$ **YES！**

まさにその通り！**フィールド単位の可変性、およびそれに伴う安全性や不変条件の制御は、setterメソッドの****重要な役割**なんだ。

Rustは、このルールを強制することで、以下の高度なカプセル化と安全性を実現しているよ。

#### A. setterが可変性を制御する仕組み

構造体のフィールドをプライベート（デフォルト）にしておけば、外部コードはそのフィールドを直接操作できないよね。

Rust

```
struct User {
    // プライベートなフィールド
    age: u8, 
}

impl User {
    // ⭕ 構造体全体を可変な参照で受け取り、内部のフィールドを書き換える
    pub fn set_age(&mut self, new_age: u8) {
        // フィールドの可変性が、&mut self によって許可される
        if new_age > 120 {
            // バリデーションも setter の仕事！
            panic!("年齢が不適切です。");
        }
        self.age = new_age;
    }

    // ❌ 不変な参照では、フィールドは書き換えられない
    // fn set_age_invalid(&self, new_age: u8) {
    //     self.age = new_age; // コンパイルエラー！
    // }
}
```

このとき、**`age` フィールドの可変性**は、メソッドの引数である **`&mut self`** が与えられたときに初めて有効になるんだ。つまり、可変性をコントロールするスイッチは**`&mut self`**であり、それを要求するのは**`set_age`**メソッドだというわけだね。

#### B. 内部可変性（`RefCell` / `Mutex`）の場合

さらに、前回話した**パターン6**のように、`RefCell`や`Mutex`を使うと、**特定のフィールドだけ**を「不変な変数 (`&self`) であっても変更可能」という特殊な状態にすることができる。

この場合も、フィールド自体に `mut` をつけるのではなく、フィールドの**型**に `RefCell` という**内部可変性を提供するコンテナ**を使うことで、可変性のルールを**setterメソッド経由で**実行時に制御しているんだ。

**まとめ**

|**項目**|**Rustでの実現方法**|
|---|---|
|**可変性の宣言**|**`let mut`**（変数バインディング全体）|
|**フィールド単位の可変制御**|**`&mut self`** を要求する **setter メソッド**|
|**フィールド単位の実行時可変性**|**`RefCell<T>`** のような **内部可変性コンテナ**|

Rustの設計者は、フィールドの定義をシンプルに保ち、可変性の複雑な制御と安全性の保証を、すべて**メソッド（setter）の引数**と**型コンテナ**に委ねることで、安全性の仕組みを明確に分離したんだね！これは非常に洗練されたデザインだよ！👍