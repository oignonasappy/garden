---
tags:
  - gemini
  - algorithm
---

[[case文に副作用のある式を入れる危険性]]

> [!quote]+ Prompt
> Case文の式の全てが定数であった場合には、コンパイラによる最適化ができるの？

そうだね、その通り！🎉

`switch`文の**全ての`case`の式が定数**であった場合、ほとんどのコンパイル言語（Java、C#、C/C++など）において、コンパイラは**非常に強力な最適化**を実行できるよ！

---

## 🚀 コンパイラによる最適化の仕組み

`switch`文の条件がすべて定数であることは、コンパイラにとって**実行時の値の予測が完全に可能**であることを意味する。これにより、コンパイラは実行効率を最大化するための特別な構造に変換できるんだ。

### 1. ジャンプテーブル（Jump Table）の生成 (最も強力な最適化)

これが最も一般的な最適化で、特にC/C++やJITコンパイラ（Java、C#）で利用されるよ。

- **仕組み**: コンパイラは、`case`ラベルの値と、そのラベルに対応するコードの**メモリ上のアドレス（ポインター）**をマッピングした**「ジャンプテーブル」**というデータ構造を生成する。
    
- **実行速度**: プログラムの実行時、制御式（`switch (x)`の`x`）の値がわかると、**テーブルを参照するだけで**、対応するコードのアドレスに**一発でジャンプ**できる。
    
- **決定的な優位性**: 条件の数（ケースの数）が100個あっても、**1回の参照**で目的のコードブロックに到達できるため、`if / else if`文のように**条件を順次比較していくオーバーヘッドが完全に不要**になるんだ。
    

### 2. 二分探索木への変換

`case`ラベルの値が連続していない場合（例: `case 1:`、`case 100:`、`case 1000:`）、ジャンプテーブルがメモリを無駄に消費する可能性がある。

- この場合、コンパイラはジャンプテーブルの代わりに、**二分探索木（Binary Search Tree）**のようなデータ構造に`switch`文を変換する可能性がある。
    
- **実行速度**: これにより、最悪の場合でも**$\mathcal{O}(\log n)$**（$n$はケースの数）の時間で目的のケースを見つけられるため、依然として線形探索（`if / else if`）よりも高速になるんだ。
    

### 💡 `if / else if` との決定的な違い

**`if / else if`** は、定数式であっても基本的に**順次比較（線形探索、$\mathcal{O}(n)$）**としてコンパイルされるのに対し、**定数のみの`switch`** は**ランダムアクセス（$\mathcal{O}(1)$または$\mathcal{O}(\log n)$）**として最適化される。

そのため、ケースの数が多いほど、**定数のみの`switch`文**が圧倒的に速いという結果になるんだね！😊


> [!quote]+ Prompt
> では、式の型が異なる場合はどうなる？  
> 例えば、`1, 1.0, false, "1", obj`が混在している場合は…

おっ、今度は`switch`文の`case`ラベルに、**異なるデータ型**の式が混在した場合の挙動だね！これは、言語の**型システム**と**比較規則**によって大きく変わってくる、非常に面白いポイントだよ！🚀

結論から言うと、**式の型が混在していると、コンパイラによるジャンプテーブルへの最適化は不可能になる**ことが多く、挙動は**言語の比較ルール**に依存するんだ。

---

## 🔑 型が混在する場合の挙動（JavaScript/C# の比較）

C/C++ではそもそも定数式しか許されないので、ここでは君が詳しい**JavaScript**と**C#**を比較してみるよ。

### 1. JavaScript / TypeScript の場合 (厳密な比較はしない！)

JavaScriptの`switch`文は、内部で**厳密ではない比較（`==`演算子に似た緩い比較）**を行っているように見えますが、実際には**トリプルイコール（`===`、厳密等価演算子）**に近い比較ロジックが働いているんだ。

- **動作**: `switch`に渡された値（制御式）と、各`case`の値を**記述された順序**で比較する。
    
- **型の扱い**: `case`の比較は厳密等価（`===`）に近い。つまり、**型が異なるとマッチしない**ことが一般的だよ。
    
    - `switch (1)` の場合: `case 1.0:` とは**マッチする**（JavaScriptの`Number`型として同じ値）が、`case "1":` や `case false:` とは**型が違うためマッチしない**。
        
- **最適化**: 型が混在していると、コンパイラやJITは**ジャンプテーブルへの最適化を諦める**。なぜなら、各`case`の値が同一視されるかどうかを厳密に判断するのが難しくなるからだ。
    
- **結論**: `if/else if` のように、**上から順に**比較処理が実行される**線形探索**に近い挙動になるため、高速なジャンプ最適化の恩恵は得られない。
    

### 2. C# / Java の場合 (型の一貫性が必須)

C#やJavaのような**静的型付け言語**では、`switch`の制御式と`case`ラベルの値には、**型の一貫性**が強く求められる。

- **制限**: `case`ラベルに入れる値は、`switch`の制御式の**型と互換性がある定数**でなければならない。
    
    - 例: `switch`が`int`型を受け取る場合、`case`ラベルに`string`型やオブジェクトを入れると、通常は**コンパイルエラー**になる。
        
- **`string`型の特殊性 (C#)**: C#では`string`型を`switch`で使うことができ、その場合、コンパイラは内部的に文字列の**ハッシュ値**などを利用した**高性能なジャンプテーブル**に最適化するよ。しかし、`int`と`string`を混ぜることはできない。
    
- **結論**: 型の制約により、**そもそも型の異なる値を混在させての`switch`はできない**（あるいは、特定の型に合わせて型変換を行う必要がある）ため、**最適化の可否について議論する余地がない**ことが多い。
    

---

## 💣 `switch`に`obj`が入った場合

`obj`のような**オブジェクト参照**が`case`ラベルに入った場合、問題はさらに複雑になる。

- **オブジェクトの比較**: JavaScriptでは、オブジェクト（`obj`）は通常、**参照が同じかどうか**で比較される。`switch`の制御式と`case`ラベルのオブジェクトが**メモリ上の同じインスタンス**を指していない限り、マッチすることはない。
    
- **最適化の放棄**: コンパイラは、オブジェクトの比較は実行時まで判断できないと判断し、**最適化を完全に放棄する**よ。
    

したがって、`switch`文を高速な分岐処理として使いたい場合は、**単純な整数や文字列といった定数**で型を統一することが、**最適化のための絶対条件**なんだ！👍