---
tags:
    - c
---

<small>(むかしのメモ)</small>

多次元配列を一次元配列のようにアクセスします。

ですがこの方法は可読性があぼーんなので避けるべきでしょう。

それを踏まえたうえで。

---

```c
#include <stdio.h>

const int A = 2, B = 3, C = 4, D = 5, E = 6;

int f(int *tensor, int a, int b, int c, int d, int e)
{
    // tensor[a][b][c][d][e] と同義
    int idx = a * B * C * D * E + 
              b * C * D * E + 
              c * D * E + 
              d * E + 
              e;
    return tensor[idx];
}

int main(void)
{
    int tensor[A][B][C][D][E] = {/* 0からの連番 */};
    int a = 1, b = 2, c = 3, d = 4, e = 5;
    printf("%d\\n", f((int *)tensor, a, b, c, d, e));
    // 719
}
```

その”次元”へのアクセスにはその次元の”下”の全ての次元の要素数と掛けます。

---

### 以下種明し・蛇足・豆知識

多次元配列は多次元構造に見せかけているだけで、本質的には一次元配列と同じです。

以下の二次元構造`matrix[3][3]`は

0 1 2 3 4 5 6 7 8

メモリ上には

0 1 2 3 4 5 6 7 8

のように配置されています。

添え字でのアクセスは内部ではこのようになっています

```c
/* 
matrix[y][1] yの値を変化させる
y : -0--1--2-
    012345678
matrix[1][x] xの値を変化させる
x : ---012---
    012345678
*/
```

C言語は自由な言語なので、実はxを負の値・要素数以上の値にしても正常に動作します。

C言語と言えば自由なメモリ操作！メモリ格納の仕組みはいくら知っていても損はないでしょ

![[Pasted image 20251227010806.png]]

artwork by Kamelie

おわり