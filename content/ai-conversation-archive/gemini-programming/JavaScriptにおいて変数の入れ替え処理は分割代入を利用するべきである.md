---
tags:
  - gemini
  - javascript
  - algorithm
---

> [!quote]+ Prompt
> Javascriptにおいて、これらはどちらが高速？
> ```
> temp = a;
> a = b;
> b = temp;
> ```
> 
> `[a, b] = [b, a];`

その比較は、JavaScriptの**実行効率とモダンな構文**に関する、非常に良い疑問だね！🚀

結論から言うと、**現代のJavaScriptエンジン（V8など）では、** **速度に決定的な差はほとんどなく、むしろ可読性の高い分割代入（`[a, b] = [b, a]`）を使うべき** **だよ**。

しかし、実行される処理の**内部的なメカニズム**には違いがあるんだ。

---

## 🔑 速度と内部メカニズムの比較

### 1. 一時変数を使った伝統的なスワップ (Temporary Variable Swap)

JavaScript

```
temp = a;
a = b;
b = temp;
```

- **動作**: 明示的に**メモリ上の新しいスロット（`temp`）**を使って、値を一時的に格納し、交換する。
    
- **コンパイラの最適化**: 実行順序が明確なため、コンパイラは非常に古い時代からこのパターンを認識している。
    
- **速度**: **非常に高速**。コンパイラは`temp`を使っていることを知っていても、**レジスタ割り当て**などの低レベルな最適化によって、`temp`変数をメモリに書き込むコスト自体を回避している場合が多い。
    

### 2. 分割代入を使ったスワップ (Destructuring Swap)

JavaScript

```
[a, b] = [b, a];
```

- **動作**:
    
    1. まず、右辺の`[b, a]`によって**新しい配列**がメモリ上に作成される。
        
    2. その新しい配列の要素が、左辺の変数`a`と`b`に**順次代入**される。
        
- **コンパイラの最適化**:
    
    - モダンなJITコンパイラ（V8など）は、この分割代入のパターンを認識すると、「これはスワップである」と判断し、**裏側で一時変数を使ったパターンとほぼ同じ機械語**に最適化するんだ。
        
    - つまり、**「新しい配列を作成する」という見かけ上のオーバーヘッド**を、コンパイラが**実行しない**ように最適化（アボリション、除去）していることが多い。
        

---

## ⚖️ 結論：パフォーマンスと可読性のトレードオフ

|**項目**|**一時変数を使ったスワップ**|**分割代入を使ったスワップ**|
|---|---|---|
|**可読性**|低い（何をしたいか一瞬考える）|**非常に高い**（スワップが一目でわかる）|
|**理論上のオーバーヘッド**|少ない（メモリ操作3回）|**わずかに高い**（一時配列の作成）|
|**実測上の速度**|**ほぼ同じ**|**ほぼ同じ**（コンパイラが最適化するため）|
|**推奨**|**非推奨**（コードが古く見える）|**推奨**（モダンでバグが少ない）|

結論として、君がプログラミングをする上で**「速度を理由に」**一時変数を使う必要は、現代のJavaScript環境ではほとんどないよ。

**分割代入**は、コードの意図が明確でバグの混入を防げるため、**プログラマとしての生産性**と**コードの品質**において圧倒的に優位だよ！👍